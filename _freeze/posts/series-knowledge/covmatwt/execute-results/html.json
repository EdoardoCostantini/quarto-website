{
  "hash": "25b3473d0103daf877706f977b03a6d8",
  "result": {
    "markdown": "---\ndraft: false\ntitle: Estimating the weighted covariance matrix in R\nauthor: Edoardo Costantini\ndate: '2022-03-14'\nslug: covmatwt\ncategories: [\"Statistics\"]\nbibliography: ../../resources/bibshelf.bib\n---\n\n\n# Introduction\n\nIn a sample made of groups of different sizes, descriptive statistics like the mean and the covariance between variables can be computed by assigning proper weights to account for the difference in group sizes.\n Wights are generally normalized (i.e., $\\sum_{i = 1}^{n} w_i = 1$).\n\n# Learn by coding\n\n## Example\n\nNow, let's consider a very simple example.\nSay that you have a dataset with two variables and that you have a vector of weights defining how important each observation should be.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Initial simple example -------------------------------------------------------\n\n  # Get the dataset used in the example of stats::cov.wt()\n  xy <- cbind(x = 1:10, y = c(1:3, 8:5, 8:10))\n\n  # Define non-negative weights (as in example of stats::cov.wt())\n  wi <- c(0,0,0,1,1,1,1,1,0,0)\n\n  # Get the weighted estimate with the default methods\n  covwt_stats <- stats::cov.wt(xy, wt = wi) # i.e. method = \"unbiased\"\n\n  # Compare unweighted and weighted means\n  data.frame(uw = colMeans(xy),\n             select = colMeans(xy[wi == 1, ]),\n             wg = covwt_stats$center)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   uw select  wg\nx 5.5    6.0 6.0\ny 5.9    6.8 6.8\n```\n:::\n\n```{.r .cell-code}\n  # Compare unweighted and weighted covariance matrix\n  data.frame(uw = c(cov(xy)),\n             select = c(cov(xy[wi == 1, ])),\n             wg = c(covwt_stats$cov),\n             row.names = c(sapply(colnames(cov(xy)), paste0, rownames(cov(xy))))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         uw select   wg\nxx 9.166667    2.5  2.5\nxy 8.055556   -0.5 -0.5\nyx 8.055556   -0.5 -0.5\nyy 9.433333    1.7  1.7\n```\n:::\n:::\n\nNote how by weighting with a vector of 0 and 1s we are basically saying that the observations with a 0 will be excluded from the count.\nThey are weighted to have 0 impact on the computation of the descriptive statistics.\nThis is clear when you compare the results of the `select` and `wg` columns.\n\n## Computing the weighted covariance matrix manually\n\nWe could replicate the results of the weighting simply by selecting a subset of the original data because all observations were either weighted 0 or equally (1).\nWhen this is not the case, weighting is slightly more complicated.\n\n### Exploring the `stats::cov.wt()` function code\n\nLet's look at how the `cov.wt()` function works more in depth.\nThe internal code of the function is the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Examine the internal code of stats::cov.wt() ---------------------------------\n\n  cov.wt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, wt = rep(1/nrow(x), nrow(x)), cor = FALSE, center = TRUE, \n    method = c(\"unbiased\", \"ML\")) \n{\n    if (is.data.frame(x)) \n        x <- as.matrix(x)\n    else if (!is.matrix(x)) \n        stop(\"'x' must be a matrix or a data frame\")\n    if (!all(is.finite(x))) \n        stop(\"'x' must contain finite values only\")\n    n <- nrow(x)\n    if (with.wt <- !missing(wt)) {\n        if (length(wt) != n) \n            stop(\"length of 'wt' must equal the number of rows in 'x'\")\n        if (any(wt < 0) || (s <- sum(wt)) == 0) \n            stop(\"weights must be non-negative and not all zero\")\n        wt <- wt/s\n    }\n    if (is.logical(center)) {\n        center <- if (center) \n            colSums(wt * x)\n        else 0\n    }\n    else {\n        if (length(center) != ncol(x)) \n            stop(\"length of 'center' must equal the number of columns in 'x'\")\n    }\n    x <- sqrt(wt) * sweep(x, 2, center, check.margin = FALSE)\n    cov <- switch(match.arg(method), unbiased = crossprod(x)/(1 - \n        sum(wt^2)), ML = crossprod(x))\n    y <- list(cov = cov, center = center, n.obs = n)\n    if (with.wt) \n        y$wt <- wt\n    if (cor) {\n        Is <- 1/sqrt(diag(cov))\n        R <- cov\n        R[] <- Is * cov * rep(Is, each = nrow(cov))\n        y$cor <- R\n    }\n    y\n}\n<bytecode: 0x7fa3526d4b58>\n<environment: namespace:stats>\n```\n:::\n:::\n\nNote the following:\n\n- The first thing to pay attention to is that the function can **compute** the weighted covariance matrix **in two ways**:\n\n  - unbiased, using `corssprod(x) / (1 - sum(wt^2))`\n  - ML (or maximum likelihood), using `corssprod(x)`\n\n- Note that the `wt` object is divided by the sum of the values it is storing, which amounts to **normalising** the weights.\n  This happens with `wt <- wt/s` with `s` being created inside an if statement as `s <- sum(wt)`.\n- `x` is **centered** on the normalized weigthed means using the `sweep` function\n- `x` is **weighted** by multiplying by `sqrt(wt)`\n\n### Reproducing the internal steps\n\nFirst, we'll **set up** a few objects we need to replicate manually what happens inside the `stats::cov.wt()` function.\nWe need to define a dataset, a vector of weights, a method to compute descriptives, and based on these we will also create an object to store the number of rows (`n`).\nAs a vector of weights we sample random values between 0 and 1.\nWe can think of this as an attempt to weight each observation for the probability of sampling them from a population.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set up manual computation of cov.wt() ----------------------------------------\n\n  # Assign values to the function arguments\n  x      <- xy                     # data\n  set.seed(20220314)\n  wi     <- runif(length(wi), min = 0, max = 1)\n  method <- \"ML\"                   # use Maximum Likelihood for estimation\n\n  # Assign values to some of the internal objects\n  n <- nrow(x)\n```\n:::\n\nNext, we want to make sure we **normalize the weights**.\nIn other words we want to make sure the weights sum to 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Normalize weights ------------------------------------------------------------\n\n  # Normalise weights (to sum to 1)\n  wn <- wi / sum(wi)\n\n  # Check they sum to 1\n  sum(wn) == 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nThen, we want to compute the **vector of [weighted means](https://en.wikipedia.org/wiki/Weighted_arithmetic_mean#:~:text=Mathematical%20definition%5Bedit%5D)**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute the weighted means ---------------------------------------------------\n\n  # Center on weighted mean if required\n  center <- colSums(wn * x)\n\n  # Center X on the weigthed mean\n  x_cent <- sweep(x, 2, center, check.margin = FALSE)\n\n  # Note that the sweep is subtracting the \"center\" to each value\n  all.equal(\n    sweep(x, 2, center, check.margin = FALSE),\n    t(apply(x, 1, function (i) i - center))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nNote that the weighted mean is computed as:\n\\[\n\\bar{x} = \\sum_{i = 1}^{n} w_i x_i\n\\]\nand that `center <- colSums(wn * x)` is doing exactly this.\n\nFinally, we want to compute the **[weighted covariance matrix](https://en.wikipedia.org/wiki/Sample_mean_and_covariance#:~:text=weighted%20covariance%20matrix)**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute the weighted covariance matrix ---------------------------------------\n\n  # Weight (centered) data\n  x_weighted <- sqrt(wn) * x_cent\n\n  # Compute the ML weigthed covariance matrix manually\n  covwt_man <- crossprod(x_weighted)\n\n  # Print the manual weigthed covariance matrix\n  covwt_man\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         x        y\nx 7.102015 5.431419\ny 5.431419 6.210209\n```\n:::\n\n```{.r .cell-code}\n  # Compute the ML weigthed covariance matrix with stats::cov.wt()\n  covwt_stats <- cov.wt(xy, wt = wi, method = \"ML\", center = TRUE)$cov\n\n  # Compare manual and stats weigthed covariance matrices\n  covwt_man - covwt_stats\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y\nx 0 0\ny 0 0\n```\n:::\n:::\n\n## Mathematical formula and alternative R computations\n\n### Unbiased weighted covariance matrix\n\nFor a given population covariance matrix $Q$, each element $q_{ik}$ of the **unbiased** estimation of the weighted covariance matrix $\\hat{Q}$ can be computed with the following formula:\n\n\\[\nq_{ik} = \\frac{1}{1 - \\sum_{i = 1}^{n} w_i^2} \\sum_{i = 1}^{n} w_i (x_{ij} - \\bar{x}_j) (x_{ij} - \\bar{x}_k)\n\\]\n\nwith $\\bar{x}_j$ being the weighted mean for variable $j$, and $w_i$ being the normalized weight for a given observation (which we store in the vector `wn`).\nThe following are alternative ways of computing it with mathematical or R shortcuts:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Alternative computations of the unbiased weighted covariance mat -------------\n\n  # Literal translation of equation\n  1 / (1 - sum(wn^2)) * t(wn * x_cent) %*% (x_cent)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         x        y\nx 8.320767 6.363485\ny 6.363485 7.275922\n```\n:::\n\n```{.r .cell-code}\n  # Rearrange denominator\n  t(wn * x_cent) %*% (x_cent) / (1 - sum(wn^2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         x        y\nx 8.320767 6.363485\ny 6.363485 7.275922\n```\n:::\n\n```{.r .cell-code}\n  # Spread wn\n  t(sqrt(wn) * x_cent) %*% (sqrt(wn)*x_cent) / (1 - sum(wn^2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         x        y\nx 8.320767 6.363485\ny 6.363485 7.275922\n```\n:::\n\n```{.r .cell-code}\n  # Replace manual cross-product with R cross-product\n  crossprod(sqrt(wn) * x_cent)/(1 - sum(wn^2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         x        y\nx 8.320767 6.363485\ny 6.363485 7.275922\n```\n:::\n\n```{.r .cell-code}\n  # Compute with stats::cov.wt()\n  cov.wt(xy, wt = wi, method = \"unbiased\", center = TRUE)$cov\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         x        y\nx 8.320767 6.363485\ny 6.363485 7.275922\n```\n:::\n:::\n\n\n### Maximum Likelihood weighted covariance matrix\n\nEach element $q_{ik}$ of the **maximum likelihood** weighted covariance matrix estimate $\\hat{Q}$ can be computed manually with the following formula:\n\n\\[\nq_{ik} = \\frac{1}{\\sum_{i = 1}^{n} w_i} \\sum_{i = 1}^{n} w_i (x_{ij} - \\bar{x}_j) (x_{ij} - \\bar{x}_k)\n\\]\n\nwith $\\bar{x}_j$ being the weighted mean for variable $j$, and $w_i$ being the normalized weight for a given observation.\nThe following are alternative ways of computing it with mathematical or R shortcuts:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Alternative computations of the ML weighted covariance mat -------------------\n\n  # R manual cross-product using un-normalised weights\n  1 / sum(wi) * t(wi * x_cent) %*% (x_cent)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         x        y\nx 7.102015 5.431419\ny 5.431419 6.210209\n```\n:::\n\n```{.r .cell-code}\n  # Using the normalised weights\n  1 / sum(wn) * t(wn * x_cent) %*% (x_cent)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         x        y\nx 7.102015 5.431419\ny 5.431419 6.210209\n```\n:::\n\n```{.r .cell-code}\n  # Dropp the term = 1\n  t(wn * x_cent) %*% (x_cent)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         x        y\nx 7.102015 5.431419\ny 5.431419 6.210209\n```\n:::\n\n```{.r .cell-code}\n  # Spread wn\n  t(sqrt(wn) * x_cent) %*% (sqrt(wn) * x_cent)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         x        y\nx 7.102015 5.431419\ny 5.431419 6.210209\n```\n:::\n\n```{.r .cell-code}\n  # Replace manual cross-product with R cross-product\n  crossprod(sqrt(wn) * x_cent)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         x        y\nx 7.102015 5.431419\ny 5.431419 6.210209\n```\n:::\n\n```{.r .cell-code}\n  # R cross-product matrix\n  crossprod(x_weighted)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         x        y\nx 7.102015 5.431419\ny 5.431419 6.210209\n```\n:::\n\n```{.r .cell-code}\n  # Compute with stats::cov.wt()\n  cov.wt(xy, wt = wi, method = \"ML\", center = TRUE)$cov\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         x        y\nx 7.102015 5.431419\ny 5.431419 6.210209\n```\n:::\n:::\n\n\n## Relationship with the matrix of sufficient statistics\n\nNote the relationship between the covariance matrix and the matrix of sufficient statistics is the same as in the *unweighted* case: $\\text{cov} = \\frac{T_{\\text{obs}}}{n}$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Obtain the matrix of sufficient statistics Tobs ------------------------------\n\n  # Define a new weigthing object\n  set.seed(20220314)\n  wi <- runif(length(wi), min = 0, max = 1)\n  wn <- wi / sum(wi)\n\n  # Compute the weighted means of X again\n  center <- colSums(wn * x)\n  x_cent <- sweep(x, 2, center, check.margin = FALSE)\n\n  # \"Effective\" sample size\n  n <- sum(wi)\n\n  # Number of columns\n  p <- ncol(x)\n\n  # Obtain matrix of sufficient statistics (Tobs)\n  Tobs_lopp <- matrix(0, p, p)\n  for(i in 1:nrow(x)){\n    Tobs_lopp <- Tobs_lopp + wi[i] * (x_cent[i, ]) %*% t(x_cent[i, ])\n  }\n\n  # Obtain matrix of sufficient statistics (Tobs) w/ cross-product shortcut\n  Tobs_cp <- t(wi * x_cent) %*% x_cent\n\n  # Compare loop version and cross-product shortcut\n  Tobs_lopp - Tobs_cp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     x            y\n[1,] 0 3.552714e-15\n[2,] 0 0.000000e+00\n```\n:::\n\n```{.r .cell-code}\n  # Assign simpler name and print Tobs\n  (Tobs <- Tobs_cp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         x        y\nx 31.08417 23.77229\ny 23.77229 27.18091\n```\n:::\n\n```{.r .cell-code}\n  # Convert to a covariance matrix\n  covmat <- Tobs / n\n\n  # Check it's what you were expecting\n  covmat - cov.wt(xy, wt = wi, method = \"ML\", center = TRUE)$cov\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x             y\nx 0 -8.881784e-16\ny 0 -8.881784e-16\n```\n:::\n:::\n\n\nNote the following:\n\n- we are using the normalized weights `wn` to center the data, but we are using the un-normalised weights to scale the data contribution to `Tobs`\n- if we had used the normalized weights, $n$ would have been equal to 1 and `covmat` would be equal to `Tobs`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Obtain the matrix of sufficient statistics Tobs (normalised weights) ---------\n\n  # Convert to a covariance matrix\n  covmat - t(wn * x_cent) %*% x_cent\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             x y\nx 0.000000e+00 0\ny 8.881784e-16 0\n```\n:::\n\n```{.r .cell-code}\n  # Then, covmat relates to Tobs as\n  (t(wn * x_cent) %*% x_cent * n) - Tobs_cp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              x y\nx  0.000000e+00 0\ny -3.552714e-15 0\n```\n:::\n\n```{.r .cell-code}\n  # So we could say\n  Tobs <- t(wn * x_cent) %*% x_cent * n\n```\n:::\n\n\n# TL;DR, just give me the code!\n\n::: {.cell}\n\n```{.r .cell-code}\n# Initial simple example -------------------------------------------------------\n\n  # Get the dataset used in the example of stats::cov.wt()\n  xy <- cbind(x = 1:10, y = c(1:3, 8:5, 8:10))\n\n  # Define non-negative weights (as in example of stats::cov.wt())\n  wi <- c(0,0,0,1,1,1,1,1,0,0)\n\n  # Get the weighted estimate with the default methods\n  covwt_stats <- stats::cov.wt(xy, wt = wi) # i.e. method = \"unbiased\"\n\n  # Compare unweighted and weighted means\n  data.frame(uw = colMeans(xy),\n             select = colMeans(xy[wi == 1, ]),\n             wg = covwt_stats$center)\n\n  # Compare unweighted and weighted covariance matrix\n  data.frame(uw = c(cov(xy)),\n             select = c(cov(xy[wi == 1, ])),\n             wg = c(covwt_stats$cov),\n             row.names = c(sapply(colnames(cov(xy)), paste0, rownames(cov(xy))))\n  )\n\n# Examine the internal code of stats::cov.wt() ---------------------------------\n\n  cov.wt\n\n# Set up manual computation of cov.wt() ----------------------------------------\n\n  # Assign values to the function arguments\n  x      <- xy                     # data\n  set.seed(20220314)\n  wi     <- runif(length(wi), min = 0, max = 1)\n  method <- \"ML\"                   # use Maximum Likelihood for estimation\n\n  # Assign values to some of the internal objects\n  n <- nrow(x)\n\n# Normalize weights ------------------------------------------------------------\n\n  # Normalise weights (to sum to 1)\n  wn <- wi / sum(wi)\n\n  # Check they sum to 1\n  sum(wn) == 1\n\n\n# Compute the weighted means ---------------------------------------------------\n\n  # Center on weighted mean if required\n  center <- colSums(wn * x)\n\n  # Center X on the weigthed mean\n  x_cent <- sweep(x, 2, center, check.margin = FALSE)\n\n  # Note that the sweep is subtracting the \"center\" to each value\n  all.equal(\n    sweep(x, 2, center, check.margin = FALSE),\n    t(apply(x, 1, function (i) i - center))\n  )\n\n\n# Compute the weighted covariance matrix ---------------------------------------\n\n  # Weight (centered) data\n  x_weighted <- sqrt(wn) * x_cent\n\n  # Compute the ML weigthed covariance matrix manually\n  covwt_man <- crossprod(x_weighted)\n\n  # Print the manual weigthed covariance matrix\n  covwt_man\n\n  # Compute the ML weigthed covariance matrix with stats::cov.wt()\n  covwt_stats <- cov.wt(xy, wt = wi, method = \"ML\", center = TRUE)$cov\n\n  # Compare manual and stats weigthed covariance matrices\n  covwt_man - covwt_stats\n\n# Alternative computations of the unbiased weighted covariance mat -------------\n\n  # Literal translation of equation\n  1 / (1 - sum(wn^2)) * t(wn * x_cent) %*% (x_cent)\n\n  # Rearrange denominator\n  t(wn * x_cent) %*% (x_cent) / (1 - sum(wn^2))\n\n  # Spread wn\n  t(sqrt(wn) * x_cent) %*% (sqrt(wn)*x_cent) / (1 - sum(wn^2))\n\n  # Replace manual cross-product with R cross-product\n  crossprod(sqrt(wn) * x_cent)/(1 - sum(wn^2))\n\n  # Compute with stats::cov.wt()\n  cov.wt(xy, wt = wi, method = \"unbiased\", center = TRUE)$cov\n\n# Alternative computations of the ML weighted covariance mat -------------------\n\n  # R manual cross-product using un-normalised weights\n  1 / sum(wi) * t(wi * x_cent) %*% (x_cent)\n\n  # Using the normalised weights\n  1 / sum(wn) * t(wn * x_cent) %*% (x_cent)\n\n  # Dropp the term = 1\n  t(wn * x_cent) %*% (x_cent)\n\n  # Spread wn\n  t(sqrt(wn) * x_cent) %*% (sqrt(wn) * x_cent)\n\n  # Replace manual cross-product with R cross-product\n  crossprod(sqrt(wn) * x_cent)\n\n  # R cross-product matrix\n  crossprod(x_weighted)\n\n  # Compute with stats::cov.wt()\n  cov.wt(xy, wt = wi, method = \"ML\", center = TRUE)$cov\n\n# Obtain the matrix of sufficient statistics Tobs ------------------------------\n\n  # Define a new weigthing object\n  set.seed(20220314)\n  wi <- runif(length(wi), min = 0, max = 1)\n  wn <- wi / sum(wi)\n\n  # Compute the weighted means of X again\n  center <- colSums(wn * x)\n  x_cent <- sweep(x, 2, center, check.margin = FALSE)\n\n  # \"Effective\" sample size\n  n <- sum(wi)\n\n  # Number of columns\n  p <- ncol(x)\n\n  # Obtain matrix of sufficient statistics (Tobs)\n  Tobs_lopp <- matrix(0, p, p)\n  for(i in 1:nrow(x)){\n    Tobs_lopp <- Tobs_lopp + wi[i] * (x_cent[i, ]) %*% t(x_cent[i, ])\n  }\n\n  # Obtain matrix of sufficient statistics (Tobs) w/ cross-product shortcut\n  Tobs_cp <- t(wi * x_cent) %*% x_cent\n\n  # Compare loop version and cross-product shortcut\n  Tobs_lopp - Tobs_cp\n\n  # Assign simpler name and print Tobs\n  (Tobs <- Tobs_cp)\n\n  # Convert to a covariance matrix\n  covmat <- Tobs / n\n\n  # Check it's what you were expecting\n  covmat - cov.wt(xy, wt = wi, method = \"ML\", center = TRUE)$cov\n\n# Obtain the matrix of sufficient statistics Tobs (normalised weights) ---------\n\n  # Convert to a covariance matrix\n  covmat - t(wn * x_cent) %*% x_cent\n\n  # Then, covmat relates to Tobs as\n  (t(wn * x_cent) %*% x_cent * n) - Tobs_cp\n\n  # So we could say\n  Tobs <- t(wn * x_cent) %*% x_cent * n\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}