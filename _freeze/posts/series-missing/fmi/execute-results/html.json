{
  "hash": "abfac1f43a6a058f57c3fea5e46b3887",
  "result": {
    "markdown": "---\ndraft: true\ntitle: Fraction of missing information\nauthor: Edoardo Costantini\ndate: '2022-09-20'\nslug: fmi\ncategories: [\"missing values\"]\nbibliography: ../../resources/bibshelf.bib\n---\n\n\n# Fraction of missing information\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Mice computation of FMI -----------------------------------------------------\n\n# Load package\nlibrary(mice)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'mice'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:stats':\n\n    filter\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    cbind, rbind\n```\n:::\n\n```{.r .cell-code}\n# Define parameters\nn <- 50\nb0 <- 10\nb1 <- 5\nb2 <- 5\nb3 <- 0\n\n# Sample X data\nX <- MASS::mvrnorm(\n    n = n,\n    mu = rep(0, 3),\n    Sigma = matrix(c(\n        1, .5, 0,\n        .5, 1, 0,\n        0, 0, 1\n    ), nrow = 3)\n)\n\n# Sample Y from DGM\ny <- b0 + b1 * X[, 1] + b2 * X[, 2] + b3 * X[, 3] + rnorm(n)\n\n# Put together in a data frame\ndt <- data.frame(y = y, X = X)\n\n# Compute the probabilities of nonresponse:\nprobs <- plogis(X[, 2])\n\n# Return a logical nonresponse vector:\nwy <- (as.logical(rbinom(n = n, size = 1, prob = probs)))\n\n# Impose missingness\ndt$y[wy] <- NA\n\n# Impute with Bayesian imputation\nm <- 5 # number of finaldata sets\nimp <- mice(dt, method = \"norm\", m = m, print = FALSE)\n\n# Fit a model to the multiple imputations\nk <- 1 + 3 # number of parameters\nfit.imp <- with(imp, lm(y ~ X.1 + X.2 + X.3))\n\n# Pool statistics\npool.imp <- pool(fit.imp)\n\n# Compute manually ------------------------------------------------------------\n# Notes: page and equation numbers refer to van Buuren 2018\n\n# > Compute Q_bar (p. 42, eq. 2.16) -------------------------------------------\n\n    # Extract vector of estimates for the first parameter\n    Q_hat_vec <- sapply(\n        fit.imp$analyses,\n        function(x) {\n            coef(x)[\"X.1\"]\n        }\n    )\n\n    # Obtain the pooled parameter\n    Q_bar <- mean(Q_hat_vec)\n\n# > Compute U_bar (p. 43, eq. 2.18) -------------------------------------------\n\n    # Extract vector of standard errors\n    U_bar_l <- sapply(\n        fit.imp$analyses,\n        function(x) {\n            (coef(summary(x))[\"X.1\", \"Std. Error\"])^2\n        }\n    )\n\n    # Obtain the pooled parameter\n    U_bar <- mean(U_bar_l)\n\n# > Compute B (p. 43, eq. 2.19) -----------------------------------------------\n\n    B <- sum((Q_hat_vec - Q_bar)^2) / (m - 1)\n\n    # Obtain the pooled parameter\n    U_bar <- mean(U_bar_l)\n\n# > Compute T (p. 43, eq. 2.20) -----------------------------------------------\n\n    T <- U_bar + B + B/m\n\n# > Lambda (p. 46, eq. 2.24) --------------------------------------------------\n#   Interpretation: proportion of variation attributable to the missing data\n#   - lambda = 0 -> missing data do not add extra variation to parameter \n#                   sampling variance\n#   - lambda = 1 -> missing data causes all of the variation in the parameter \n#                   estimate\n#   - lambda > .5 -> influence of the imputation model on the final result is \n#                   larger than complete-data\n\n    lambda <- (B + B/m) / T\n\n# > Relative increase in variance due to nonresponse (p. 47, eq. 2.25) --------\n\n    r <- (B + B / m) / U_bar\n\n    # Related to lambda\n    c(r, lambda / (1-lambda))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.428686 1.428686\n```\n:::\n\n```{.r .cell-code}\n# > Degrees of freedom (old) --------------------------------------------------\n#   Interpretation: number of observations after accounting for the number of \n#                   parameters in the model.\n#   - nu_old =~ m - 1 if lambda is ~1, meaning all variation due to nonresponse\n#   - nu_old =~ Inf   if lambda is ~0, meaning all variation due to sampling\n\n    nu_old <- (m - 1) * (1 + 1 / r^2)\n    nu_old <- (m - 1) / lambda^2\n\n# > Degrees of freedom (com) --------------------------------------------------\n#   Interpretation: degrees of freedom of Q_bar in the hypothetically complete\n#                   data\n\n    nu_com <- n - k\n\n# > Degrees of freedom (obs) --------------------------------------------------\n#   Interpretation: estimated observed data degrees of freedom accounting for \n#                   missing information\n\n    nu_obs <- (nu_com + 1) / (nu_com + 3) * nu_com * (1 - lambda)\n\n# > Degrees of freedom (adjusted) ---------------------------------------------\n#   Interpretation: adjusted degrees of freedom to be used for testing in\n#                   multiple imputation\n#   - nu <= nu_com  always!\n#   - nu =  nu_old  if nu_com = Inf\n#   - nu =  nu_com  if lambda = 0\n#   - nu =  0       if lambda = 1 (which makes no sense)\n#   - nu <  1       refrain from testing due to lack of info\n\n    nu <- nu_old * nu_obs / (nu_old + nu_obs)\n\n# > Fraction of information missing due to nonresponse (p. 47, eq. 2.25) ------\n#   Interpretation: proportion of variation attributable to the missing data\n#                   -> ADJUSTED for the finite number of imputations\n#   - gamma = 0 -> missing data do not add extra variation to parameter\n#                  sampling variance\n#   - gamma = 1 -> missing data causes all of the variation in the parameter\n#                  estimate\n#   - gamma > .5 -> influence of the imputation model on the final result is\n#                  larger than complete-data\n\n    gamma <- (r + 2/(nu + 3)) / (1 + r)\n\n    # Relation to lambda\n    # 1. Interpretation: same + ADJUSTED for a finite number of imputations\n    # 2. Computation:\n    c(\n        gamma,\n        (nu + 1) / (nu + 3) * lambda + 2 / (nu + 3)\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.670077 0.670077\n```\n:::\n\n```{.r .cell-code}\n    # 3. Use in the literature: used interchangeably, but only for large nu \n    #                           they are the same.\n\n# > Compare with mice ---------------------------------------------------------\n\n    # Results for B1\n    manual <- c(\n        Q_bar = Q_bar, U_bar = U_bar, B = B, T = T,\n        nu_com = nu_com, nu = nu,\n        r = r, lambda = lambda, gamma = gamma\n    )\n\n    # Mice results\n    mice_comp <- pool.imp$pooled[2, -(1:2)]\n\n    # Put together\n    rbind(manual, mice_comp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  estimate       ubar          b          t dfcom       df      riv    lambda\n1 4.899855 0.03601506 0.04287851 0.08746927    46 7.064385 1.428686 0.5882548\n2 4.899855 0.03601506 0.04287851 0.08746927    46 7.064385 1.428686 0.5882548\n       fmi\n1 0.670077\n2 0.670077\n```\n:::\n:::\n\n\n\n# TL;DR, just give me the code!\n\n::: {.cell}\n\n```{.r .cell-code}\n# Mice computation of FMI -----------------------------------------------------\n\n# Load package\nlibrary(mice)\n\n# Define parameters\nn <- 50\nb0 <- 10\nb1 <- 5\nb2 <- 5\nb3 <- 0\n\n# Sample X data\nX <- MASS::mvrnorm(\n    n = n,\n    mu = rep(0, 3),\n    Sigma = matrix(c(\n        1, .5, 0,\n        .5, 1, 0,\n        0, 0, 1\n    ), nrow = 3)\n)\n\n# Sample Y from DGM\ny <- b0 + b1 * X[, 1] + b2 * X[, 2] + b3 * X[, 3] + rnorm(n)\n\n# Put together in a data frame\ndt <- data.frame(y = y, X = X)\n\n# Compute the probabilities of nonresponse:\nprobs <- plogis(X[, 2])\n\n# Return a logical nonresponse vector:\nwy <- (as.logical(rbinom(n = n, size = 1, prob = probs)))\n\n# Impose missingness\ndt$y[wy] <- NA\n\n# Impute with Bayesian imputation\nm <- 5 # number of finaldata sets\nimp <- mice(dt, method = \"norm\", m = m, print = FALSE)\n\n# Fit a model to the multiple imputations\nk <- 1 + 3 # number of parameters\nfit.imp <- with(imp, lm(y ~ X.1 + X.2 + X.3))\n\n# Pool statistics\npool.imp <- pool(fit.imp)\n\n# Compute manually ------------------------------------------------------------\n# Notes: page and equation numbers refer to van Buuren 2018\n\n# > Compute Q_bar (p. 42, eq. 2.16) -------------------------------------------\n\n    # Extract vector of estimates for the first parameter\n    Q_hat_vec <- sapply(\n        fit.imp$analyses,\n        function(x) {\n            coef(x)[\"X.1\"]\n        }\n    )\n\n    # Obtain the pooled parameter\n    Q_bar <- mean(Q_hat_vec)\n\n# > Compute U_bar (p. 43, eq. 2.18) -------------------------------------------\n\n    # Extract vector of standard errors\n    U_bar_l <- sapply(\n        fit.imp$analyses,\n        function(x) {\n            (coef(summary(x))[\"X.1\", \"Std. Error\"])^2\n        }\n    )\n\n    # Obtain the pooled parameter\n    U_bar <- mean(U_bar_l)\n\n# > Compute B (p. 43, eq. 2.19) -----------------------------------------------\n\n    B <- sum((Q_hat_vec - Q_bar)^2) / (m - 1)\n\n    # Obtain the pooled parameter\n    U_bar <- mean(U_bar_l)\n\n# > Compute T (p. 43, eq. 2.20) -----------------------------------------------\n\n    T <- U_bar + B + B/m\n\n# > Lambda (p. 46, eq. 2.24) --------------------------------------------------\n#   Interpretation: proportion of variation attributable to the missing data\n#   - lambda = 0 -> missing data do not add extra variation to parameter \n#                   sampling variance\n#   - lambda = 1 -> missing data causes all of the variation in the parameter \n#                   estimate\n#   - lambda > .5 -> influence of the imputation model on the final result is \n#                   larger than complete-data\n\n    lambda <- (B + B/m) / T\n\n# > Relative increase in variance due to nonresponse (p. 47, eq. 2.25) --------\n\n    r <- (B + B / m) / U_bar\n\n    # Related to lambda\n    c(r, lambda / (1-lambda))\n\n# > Degrees of freedom (old) --------------------------------------------------\n#   Interpretation: number of observations after accounting for the number of \n#                   parameters in the model.\n#   - nu_old =~ m - 1 if lambda is ~1, meaning all variation due to nonresponse\n#   - nu_old =~ Inf   if lambda is ~0, meaning all variation due to sampling\n\n    nu_old <- (m - 1) * (1 + 1 / r^2)\n    nu_old <- (m - 1) / lambda^2\n\n# > Degrees of freedom (com) --------------------------------------------------\n#   Interpretation: degrees of freedom of Q_bar in the hypothetically complete\n#                   data\n\n    nu_com <- n - k\n\n# > Degrees of freedom (obs) --------------------------------------------------\n#   Interpretation: estimated observed data degrees of freedom accounting for \n#                   missing information\n\n    nu_obs <- (nu_com + 1) / (nu_com + 3) * nu_com * (1 - lambda)\n\n# > Degrees of freedom (adjusted) ---------------------------------------------\n#   Interpretation: adjusted degrees of freedom to be used for testing in\n#                   multiple imputation\n#   - nu <= nu_com  always!\n#   - nu =  nu_old  if nu_com = Inf\n#   - nu =  nu_com  if lambda = 0\n#   - nu =  0       if lambda = 1 (which makes no sense)\n#   - nu <  1       refrain from testing due to lack of info\n\n    nu <- nu_old * nu_obs / (nu_old + nu_obs)\n\n# > Fraction of information missing due to nonresponse (p. 47, eq. 2.25) ------\n#   Interpretation: proportion of variation attributable to the missing data\n#                   -> ADJUSTED for the finite number of imputations\n#   - gamma = 0 -> missing data do not add extra variation to parameter\n#                  sampling variance\n#   - gamma = 1 -> missing data causes all of the variation in the parameter\n#                  estimate\n#   - gamma > .5 -> influence of the imputation model on the final result is\n#                  larger than complete-data\n\n    gamma <- (r + 2/(nu + 3)) / (1 + r)\n\n    # Relation to lambda\n    # 1. Interpretation: same + ADJUSTED for a finite number of imputations\n    # 2. Computation:\n    c(\n        gamma,\n        (nu + 1) / (nu + 3) * lambda + 2 / (nu + 3)\n    )\n    # 3. Use in the literature: used interchangeably, but only for large nu \n    #                           they are the same.\n\n# > Compare with mice ---------------------------------------------------------\n\n    # Results for B1\n    manual <- c(\n        Q_bar = Q_bar, U_bar = U_bar, B = B, T = T,\n        nu_com = nu_com, nu = nu,\n        r = r, lambda = lambda, gamma = gamma\n    )\n\n    # Mice results\n    mice_comp <- pool.imp$pooled[2, -(1:2)]\n\n    # Put together\n    rbind(manual, mice_comp)\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}