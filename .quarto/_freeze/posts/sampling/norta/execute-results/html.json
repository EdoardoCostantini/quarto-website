{
  "hash": "671c6bb2c476e39c717111f36d647139",
  "result": {
    "markdown": "---\ndraft: true\ntitle: Normal to anything (NORTA) sampling\nauthor: Edoardo Costantini\ndate: '2022-10-26'\nslug: norta\ncategories: [\"distributions\"]\n---\n\n\n# Introduction\n\nThe Normal to anything (or NORTA) is a sampling approach that allows to generate multivariate data with a known correlation structure and arbitrary marginal distributions.\nFor example, you might generate 3 variables with a given correlation structure but have them take the form of beta or logistic distributions.\n\n# Learn by coding\n\nFor this topic we will need a few packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load pacakges ---------------------------------------------------------------\n\nlibrary(SimCorMultRes)\nlibrary(MASS)\nlibrary(ggplot2)\nlibrary(e1071)\n```\n:::\n\n\nThe norta approach can be summarized in two steps:\n\n  1. Sample a data matrix $X_{n \\times p}$ from a Multivariate Normal distribution with target correlation structure\n  2. Transform the distributions of the individual variables $x_j$ for $j = 1, \\dots, p$ (the marginal distributions) by `qany(pnorm())`\n\n## Sample from multivariate normal distribution\n\nFirst we sample 1000 observations from a multivariate normal distirbution with four correlated variables ($\\rho = .7$).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Sample from multivariate normal distribution -----------------------------\n\n# Set the seed\nset.seed(20210422)\n\n# Fix parameters\nn <- 1e3 # smaple size\np <- 2  # number of variables\nmu <- rep(0, p) # vector of means\nSigma <- matrix(.7, nrow = p, ncol = p); diag(Sigma) <- 1 # correlation matrix\n\n# Sample Multivairate Normal data\nX <- mvrnorm(n = n, mu = mu, Sigma = Sigma)\n```\n:::\n\n\n## Transform marginals\n\nWe can now transform the marginal distributions fo the $x$s to any target paramteric distribution. For example, consider transforming the marginals to poissan distributions. First, we compute the values of the normal cumulative distribution function (`pnorm()`) and then we compute the quantiles corresponding to the resulting cumulative probabilities based on the target marginal distribution using the `qpois()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2. Transform marginals ------------------------------------------------------\n\n# Transform to poissan\nX_pois <- qpois(pnorm(X), lambda = 2)\n```\n:::\n\n\nAs another example, consider transforming the marginals to uniform distributions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Transform to uniform\nX_unif <- qunif(pnorm(X))\n```\n:::\n\n\nWe can use this procedure to transform the marginal distribution to any target distribution.\n\n## Check correlation between the variables is still the same\n\nYou will notice that the marginal distributions of the variables have changed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 3. Checks -------------------------------------------------------------------\n# Change plotting so that you can see all variables \npar(mfrow = c(2, 3))\n\n# Loop over the columns and plot their marginal distributions\nfor(j in 1:p){\n  plot(density(X[, j]), main = paste0(\"Normal x\", j), ylab = \"\", xlab = \"\")\n  plot(density(X_pois[, j]), main = paste0(\"Poisson x\", j), ylab = \"\", xlab = \"\")\n  plot(density(X_unif[, j]), main = paste0(\"Uniform x\", j), ylab = \"\", xlab = \"\")\n}\n```\n\n::: {.cell-output-display}\n![](norta_files/figure-html/visualize-marginals-1.png){width=672}\n:::\n:::\n\n\nBut we still have the multivaraite relationship as in the original data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check that the multivariate distribution is still the same\npar(mfrow = c(1, 3))\n\n# Plot linear relationship between normal x1 and x2 (original data)\nplot(X[, 1], X[, 2], main = \"Normal marginals\", xlab = \"x1\", ylab = \"x2\")\nabline(lm(X[, 1] ~ X[, 2]), col = \"blue\", lwd = 3)\n\n# Plot linear relationship between normal x1 and x2 (original data)\nplot(X_pois[, 1], X_pois[, 2], main = \"Poissan marginal\", xlab = \"x1\", ylab = \"x2\")\nabline(lm(X_pois[, 1] ~ X_pois[, 2]), col = \"blue\", lwd = 3)\n\n# Plot linear relationship between normal x1 and x2 (original data)\nplot(X_unif[, 1], X_unif[, 2], main = \"Uniform marginal\", xlab = \"x1\", ylab = \"x2\")\nabline(lm(X_unif[, 1] ~ X_unif[, 2]), col = \"blue\", lwd = 3)\n```\n\n::: {.cell-output-display}\n![](norta_files/figure-html/visualize-multivariate-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# NORTA approach intuitive ------------------------------------------------\n# 1. Generate Multivariate Normal Distribution\n# 2. Transofrm to any distribution by qanydist(pnorm(MVN))\n# 3. Check correlation is still the same\n\n#   set.seed(20210422)\n\n# # > Step 1: Generate Multivairate Normal data\n#   n <- 1e3\n#   mu <- rep(0, 4) # Support up to 4 variables at once\n#   Sigma <- matrix(.7, nrow = 4, ncol = 4)\n#     diag(Sigma) <- 1\n#   rawvars <- mvrnorm(n = n, mu = mu, Sigma = Sigma)\n#   normXY <- data.frame(x = rawvars[, 1], y = rawvars[, 2])\n#   round(cor(rawvars), 3)\n  \n#   g <- ggplot(normXY, aes(x = x,y = y))\n#   g <- g + geom_point(size=1) + stat_smooth(method = 'lm', \n#                                             se = FALSE, \n#                                             color = 'red')\n#   plot(g)\n  \n\n# # > Step 2a: Transform Variables to a Uniform Distribution\n#   unifvars <- qunif(pnorm(rawvars))\n#   round(cor(unifvars), 3)\n  \n#   unifXY <- data.frame(x = unifvars[,1], \n#                        y = unifvars[,2])\n#   plot(density(unifXY[, 2]))\n#   g <- ggplot(unifXY, aes(x = x, y = y))\n#   g <- g + geom_point(size=1) + stat_smooth(method = 'lm',\n#                                             se = FALSE,\n#                                             color = 'red')\n#   plot(g)\n\n# # > Step 2b: Transform Variables to a Poisson Distribution\n#   poisvars <- qpois(pnorm(rawvars), 2)\n#   round(cor(poisvars), 3)\n  \n#   poisXY <- data.frame(x = poisvars[, 1], \n#                        y = poisvars[, 2])\n\n#   # Better to make point size proportional to count here\n#   g <- ggplot(poisXY, aes(x = x, y = y))\n#   g <- g + geom_point(size=1) + stat_smooth(method = 'lm',\n#                                             se = FALSE,\n#                                             color = 'red')\n#   plot(g)\n\n# # Manual Functions to do this ---------------------------------------------\n# # Create a multi-variate <dist> distribution with <samples> samples and correlation <r>\n# # Distribution names as in help(\"Distributions\")\n# # The distribution names are used to form the quantile function name q<dist>\n# # Currently additional arguments to the quantile function are not supported\n# # Curtesy of: https://rpubs.com/rseiter/50148\n#   corrdata <- function(samples = 200, r = 0, dist = \"norm\"){\n#     data = mvrnorm(n = samples, \n#                    mu = c(0, 0), \n#                    Sigma = matrix(c(1, r, r, 1), \n#                                   nrow = 2), \n#                    empirical = TRUE)\n#     distfunname <- paste0(\"q\", dist)\n#     if (!exists(distfunname)) { error(paste(\"Function\", distfunname, \"does not exist\")) }\n    \n#     # Convert the multi-variate normal variables to the desired distribution using NORTA\n#     data <- eval(parse(text = paste0(distfunname, \"(pnorm(data))\")))\n    \n#     # Check that the correlation has not changed\n#     writeLines(paste(\"Desired correlation for dist\", dist, \"was\", r,\n#                      \"  Actual correlation was\", round(cor(data)[1,2],3)))\n    \n#     data.frame(x = data[,1], y = data[,2])\n#   }\n  \n#   plotcorrdata <- function(samples=200, dist=\"norm\") {\n#     df <- data.frame()\n#     for (i in c(1, 0.8, 0.5, 0.2, 0, -0.2, -0.5, -0.8, -1)) {\n#       tmp <- corrdata(samples, i, dist)\n#       tmp['corr'] <- i\n#       df <- rbind(df, tmp)\n#     }\n    \n#     g <- ggplot(df, aes(x=x,y=y)) + geom_point(size=1)\n#     g <- g + facet_wrap(~corr) + stat_smooth(method='lm',se=FALSE,color='red')\n#     g <- g + coord_fixed() +  ggtitle(paste(\"Scatterplots for Correlated\", dist, \"Random Variables\"))\n#     plot(g)\n#   }\n  \n#   dists <- c(\"norm\", \"unif\", \"exp\")\n  \n#   for (dist in dists) {\n#     plotcorrdata(samples=200, dist=dist)\n#   }\n  \n# # NORTA sampling with SimCorMultRes package -------------------------------\n  \n#   # An example with standard logistic as marginal distribution.\n#   set.seed(1)\n#   n <- 1000\n#   Psi <- toeplitz(c(1, rep(0.8, 2))) # latent correlation matrix\n#   Psi\n#   dmarg_c <- rep(\"qlogis\", 3) # common marginal distribution\n#   X_logit <- rnorta(R = n,  # simulated logistic responses\n#                     cor.matrix = Psi,\n#                     distr = dmarg_c)\n\n#   ## The following lines exemplify the NORTA method.\n#   set.seed(1)\n#   X_norm <- rsmvnorm(R = n,\n#                      cor.matrix = Psi)\n#   X_logit_norta <- qlogis(pnorm(X_norm)) # !!!\n#   all(X_logit == X_logit_norta)\n  \n#   ## Change the marginal distributions to standard normal, standard\n#   ## logistic and standard extreme value distribution.\n#   set.seed(1)\n#   dmarg_d <- c(\"qnorm\", \"qlogis\", \"qgumbel\")\n#   X <- rnorta(R = n,\n#               cor.matrix = Psi,\n#               distr = dmarg_d)\n#   apply(X, 2, function(x) plot(density(x)))\n#   cor(X)\n#   colMeans(X)\n#   apply(X, 2, sd)\n  \n#   # Transform qlogis in binary variable\n#   prob <- exp(X[, 2]) / (exp(X[, 2])+1)\n#   p <- .7\n#   X_d <- as.numeric(prob > .5)\n#   cor(X[, 1], X_d)\n  \n#   ## Same as above but using parameter values other than the default ones.\n#   set.seed(1)\n#   qpars <- list(c(mean = 1, sd = 9), \n#                 c(location = 2, scale = 1),\n#                 c(loc = 3, scale = 1))\n#   simulated_logistic_responses <- rnorta(R = n,\n#                                          cor.matrix = Psi,\n#                                          distr = dmarg_d, \n#                                          qparameters = qpars)\n#   cor(simulated_logistic_responses)\n#   colMeans(simulated_logistic_responses)\n#   apply(simulated_logistic_responses, 2, sd)\n  \n#   # Example with poissan distribution\n#   set.seed(1)\n#   n <- 1000\n#   Psi <- toeplitz(c(1, rep(0.8, 2))) # latent correlation matrix\n#   Psi\n#   dmarg_c <- rep(\"qpois\", 3) # common marginal distribution\n#   lambda <- 4\n#   X_qpois <- rnorta(R = n,  # simulated logistic responses\n#                     cor.matrix = Psi,\n#                     distr = dmarg_c,\n#                     qparameters = list(c(lambda = lambda),\n#                                        c(lambda = lambda),\n#                                        c(lambda = lambda)))\n#   # Equivalent to\n#   X_norm <- rsmvnorm(R = n,\n#                      cor.matrix = Psi)\n#   X_pois_norta <- qpois(pnorm(X_norm), lambda = lambda) # !!!\n\n#   plot(density(X_qpois))\n#     lines(density(X_pois_norta), col = \"green\", lty = 2)\n\n# # Using Package SimCorMultRes ---------------------------------------------\n\n#   set.seed(123)\n#   sample_size <- 5000\n#   cluster_size <- 4\n#   beta_intercepts <- 0\n#   beta_coefficients <- 0.2  \n#   latent_correlation_matrix <- toeplitz(c(1, 0.9, 0.9, 0.9))\n#   x <- rep(rnorm(sample_size), each = cluster_size)\n#   simulated_binary_dataset <- rbin(clsize = cluster_size,\n#                                    intercepts = beta_intercepts, \n#                                    betas = beta_coefficients,\n#                                    xformula = ~x, \n#                                    cor.matrix = latent_correlation_matrix, \n#                                    link = \"probit\")\n#   simulated_binary_dataset$simdata\n#   cor(simulated_binary_dataset$Ysim)\n#   cor(simulated_binary_dataset$rlatent)\n  \n  \n#   library(gee)\n#   binary_gee_model <- gee(y ~ x, family = binomial(\"probit\"), id = id,\n#                           data = simulated_binary_dataset$simdata)\n#   summary(binary_gee_model)$coefficients\n\n# # Sample from the skewed normal dist by manual NORTA ----------------------\n# # (univariate)\n\n# # Packages\n# library(sn)\n# library(moments)\n\n# # Univariate case (Skewed normal)\n# n <- 1e5\n# mu <- 0\n# sd <- 1\n# skew <- .8 # target skewness\n\n# # Define parameters for the quantile functions of the skewd normal distribution\n# cp <- c(mean = mu, s.d. = sd, gamma1 = skew) # central parametrization\n# dp <- cp2dp(cp, family = \"SN\") # direct parametrization\n\n# # Obtain samples\n# set.seed(20211104)\n#   # NORTA\n#   x_norm <- rnorm(n, mu, sd) # step 1\n#   x_snorm <- qsn(pnorm(x_norm), dp = dp) # step 2\n\n#   # Azzalini method\n#   x_sn <- rsn(n, dp = dp)\n\n# # Skewness\n# skewness(x_sn)\n# skewness(x_snorm)\n\n# # Kurtosis\n# kurtosis(x_sn)\n# kurtosis(x_snorm)\n\n# # Densities\n# plot(density(x))  \n#   lines(density(x_snorm), col = \"blue\", lty = 2)\n\n# # Overcome skewed normal distribution limit of gamma < 1 ----------------------\n\n#   # The SKewed normal has the limit of gamma < 1\n\n#   # This works\n#   cp <- c(0, 1, .8)\n#   dp <- cp2dp(cp, family = \"SN\")\n#   x <- rsn(1e5, dp = dp)\n#   e1071::skewness(x)\n#   e1071::kurtosis(x)\n\n#   # But this does not\n#   cp <- c(0, 1, 2)\n#   dp <- cp2dp(cp, family = \"SN\")\n\n#   # So we move to the Skewed t distribution which allows changing the excess kurtosis\n#   cpST <- c(0, 1, 2, 10)\n#   dpST <- cp2dp(cpST, family = \"ST\")\n#   x <- rst(1e6, dp = dpST)\n#   plot(density(x))\n#   e1071::skewness(x)\n#   e1071::kurtosis(x)\n\n#   # Note a normal distribution with kurtosis\n#   cpST <- c(0, 1, 0, 0)\n#   dpST <- cp2dp(cpST, family = \"ST\")\n#   x <- rst(1e5, dp = dpST)\n#   e1071::skewness(x)\n#   e1071::kurtosis(x)\n\n#   z <- rnorm(1e5)\n#   e1071::skewness(z)\n#   e1071::kurtosis(z)\n\n#   plot(density(x))\n#   lines(density(rnorm(1e4)))\n\n#   # Push it even more\n#   cpST <- c(0, 1, 3, 40)\n#   dpST <- cp2dp(cpST, family = \"ST\")\n#   x <- rst(1e6, dp = dpST)\n#   plot(density(x))\n#   e1071::skewness(x)\n#   e1071::kurtosis(x)\n```\n:::\n\n\n# TL;DR, just give me the code!\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load pacakges ---------------------------------------------------------------\n\nlibrary(SimCorMultRes)\nlibrary(MASS)\nlibrary(ggplot2)\nlibrary(e1071)\n\n# 1. Sample from multivariate normal distribution -----------------------------\n\n# Set the seed\nset.seed(20210422)\n\n# Fix parameters\nn <- 1e3 # smaple size\np <- 2  # number of variables\nmu <- rep(0, p) # vector of means\nSigma <- matrix(.7, nrow = p, ncol = p); diag(Sigma) <- 1 # correlation matrix\n\n# Sample Multivairate Normal data\nX <- mvrnorm(n = n, mu = mu, Sigma = Sigma)\n\n# 2. Transform marginals ------------------------------------------------------\n\n# Transform to poissan\nX_pois <- qpois(pnorm(X), lambda = 2)\n\n# Transform to uniform\nX_unif <- qunif(pnorm(X))\n\n# 3. Checks -------------------------------------------------------------------\n# Change plotting so that you can see all variables \npar(mfrow = c(2, 3))\n\n# Loop over the columns and plot their marginal distributions\nfor(j in 1:p){\n  plot(density(X[, j]), main = paste0(\"Normal x\", j), ylab = \"\", xlab = \"\")\n  plot(density(X_pois[, j]), main = paste0(\"Poisson x\", j), ylab = \"\", xlab = \"\")\n  plot(density(X_unif[, j]), main = paste0(\"Uniform x\", j), ylab = \"\", xlab = \"\")\n}\n\n# Check that the multivariate distribution is still the same\npar(mfrow = c(1, 3))\n\n# Plot linear relationship between normal x1 and x2 (original data)\nplot(X[, 1], X[, 2], main = \"Normal marginals\", xlab = \"x1\", ylab = \"x2\")\nabline(lm(X[, 1] ~ X[, 2]), col = \"blue\", lwd = 3)\n\n# Plot linear relationship between normal x1 and x2 (original data)\nplot(X_pois[, 1], X_pois[, 2], main = \"Poissan marginal\", xlab = \"x1\", ylab = \"x2\")\nabline(lm(X_pois[, 1] ~ X_pois[, 2]), col = \"blue\", lwd = 3)\n\n# Plot linear relationship between normal x1 and x2 (original data)\nplot(X_unif[, 1], X_unif[, 2], main = \"Uniform marginal\", xlab = \"x1\", ylab = \"x2\")\nabline(lm(X_unif[, 1] ~ X_unif[, 2]), col = \"blue\", lwd = 3)\n\n\n# NORTA approach intuitive ------------------------------------------------\n# 1. Generate Multivariate Normal Distribution\n# 2. Transofrm to any distribution by qanydist(pnorm(MVN))\n# 3. Check correlation is still the same\n\n#   set.seed(20210422)\n\n# # > Step 1: Generate Multivairate Normal data\n#   n <- 1e3\n#   mu <- rep(0, 4) # Support up to 4 variables at once\n#   Sigma <- matrix(.7, nrow = 4, ncol = 4)\n#     diag(Sigma) <- 1\n#   rawvars <- mvrnorm(n = n, mu = mu, Sigma = Sigma)\n#   normXY <- data.frame(x = rawvars[, 1], y = rawvars[, 2])\n#   round(cor(rawvars), 3)\n  \n#   g <- ggplot(normXY, aes(x = x,y = y))\n#   g <- g + geom_point(size=1) + stat_smooth(method = 'lm', \n#                                             se = FALSE, \n#                                             color = 'red')\n#   plot(g)\n  \n\n# # > Step 2a: Transform Variables to a Uniform Distribution\n#   unifvars <- qunif(pnorm(rawvars))\n#   round(cor(unifvars), 3)\n  \n#   unifXY <- data.frame(x = unifvars[,1], \n#                        y = unifvars[,2])\n#   plot(density(unifXY[, 2]))\n#   g <- ggplot(unifXY, aes(x = x, y = y))\n#   g <- g + geom_point(size=1) + stat_smooth(method = 'lm',\n#                                             se = FALSE,\n#                                             color = 'red')\n#   plot(g)\n\n# # > Step 2b: Transform Variables to a Poisson Distribution\n#   poisvars <- qpois(pnorm(rawvars), 2)\n#   round(cor(poisvars), 3)\n  \n#   poisXY <- data.frame(x = poisvars[, 1], \n#                        y = poisvars[, 2])\n\n#   # Better to make point size proportional to count here\n#   g <- ggplot(poisXY, aes(x = x, y = y))\n#   g <- g + geom_point(size=1) + stat_smooth(method = 'lm',\n#                                             se = FALSE,\n#                                             color = 'red')\n#   plot(g)\n\n# # Manual Functions to do this ---------------------------------------------\n# # Create a multi-variate <dist> distribution with <samples> samples and correlation <r>\n# # Distribution names as in help(\"Distributions\")\n# # The distribution names are used to form the quantile function name q<dist>\n# # Currently additional arguments to the quantile function are not supported\n# # Curtesy of: https://rpubs.com/rseiter/50148\n#   corrdata <- function(samples = 200, r = 0, dist = \"norm\"){\n#     data = mvrnorm(n = samples, \n#                    mu = c(0, 0), \n#                    Sigma = matrix(c(1, r, r, 1), \n#                                   nrow = 2), \n#                    empirical = TRUE)\n#     distfunname <- paste0(\"q\", dist)\n#     if (!exists(distfunname)) { error(paste(\"Function\", distfunname, \"does not exist\")) }\n    \n#     # Convert the multi-variate normal variables to the desired distribution using NORTA\n#     data <- eval(parse(text = paste0(distfunname, \"(pnorm(data))\")))\n    \n#     # Check that the correlation has not changed\n#     writeLines(paste(\"Desired correlation for dist\", dist, \"was\", r,\n#                      \"  Actual correlation was\", round(cor(data)[1,2],3)))\n    \n#     data.frame(x = data[,1], y = data[,2])\n#   }\n  \n#   plotcorrdata <- function(samples=200, dist=\"norm\") {\n#     df <- data.frame()\n#     for (i in c(1, 0.8, 0.5, 0.2, 0, -0.2, -0.5, -0.8, -1)) {\n#       tmp <- corrdata(samples, i, dist)\n#       tmp['corr'] <- i\n#       df <- rbind(df, tmp)\n#     }\n    \n#     g <- ggplot(df, aes(x=x,y=y)) + geom_point(size=1)\n#     g <- g + facet_wrap(~corr) + stat_smooth(method='lm',se=FALSE,color='red')\n#     g <- g + coord_fixed() +  ggtitle(paste(\"Scatterplots for Correlated\", dist, \"Random Variables\"))\n#     plot(g)\n#   }\n  \n#   dists <- c(\"norm\", \"unif\", \"exp\")\n  \n#   for (dist in dists) {\n#     plotcorrdata(samples=200, dist=dist)\n#   }\n  \n# # NORTA sampling with SimCorMultRes package -------------------------------\n  \n#   # An example with standard logistic as marginal distribution.\n#   set.seed(1)\n#   n <- 1000\n#   Psi <- toeplitz(c(1, rep(0.8, 2))) # latent correlation matrix\n#   Psi\n#   dmarg_c <- rep(\"qlogis\", 3) # common marginal distribution\n#   X_logit <- rnorta(R = n,  # simulated logistic responses\n#                     cor.matrix = Psi,\n#                     distr = dmarg_c)\n\n#   ## The following lines exemplify the NORTA method.\n#   set.seed(1)\n#   X_norm <- rsmvnorm(R = n,\n#                      cor.matrix = Psi)\n#   X_logit_norta <- qlogis(pnorm(X_norm)) # !!!\n#   all(X_logit == X_logit_norta)\n  \n#   ## Change the marginal distributions to standard normal, standard\n#   ## logistic and standard extreme value distribution.\n#   set.seed(1)\n#   dmarg_d <- c(\"qnorm\", \"qlogis\", \"qgumbel\")\n#   X <- rnorta(R = n,\n#               cor.matrix = Psi,\n#               distr = dmarg_d)\n#   apply(X, 2, function(x) plot(density(x)))\n#   cor(X)\n#   colMeans(X)\n#   apply(X, 2, sd)\n  \n#   # Transform qlogis in binary variable\n#   prob <- exp(X[, 2]) / (exp(X[, 2])+1)\n#   p <- .7\n#   X_d <- as.numeric(prob > .5)\n#   cor(X[, 1], X_d)\n  \n#   ## Same as above but using parameter values other than the default ones.\n#   set.seed(1)\n#   qpars <- list(c(mean = 1, sd = 9), \n#                 c(location = 2, scale = 1),\n#                 c(loc = 3, scale = 1))\n#   simulated_logistic_responses <- rnorta(R = n,\n#                                          cor.matrix = Psi,\n#                                          distr = dmarg_d, \n#                                          qparameters = qpars)\n#   cor(simulated_logistic_responses)\n#   colMeans(simulated_logistic_responses)\n#   apply(simulated_logistic_responses, 2, sd)\n  \n#   # Example with poissan distribution\n#   set.seed(1)\n#   n <- 1000\n#   Psi <- toeplitz(c(1, rep(0.8, 2))) # latent correlation matrix\n#   Psi\n#   dmarg_c <- rep(\"qpois\", 3) # common marginal distribution\n#   lambda <- 4\n#   X_qpois <- rnorta(R = n,  # simulated logistic responses\n#                     cor.matrix = Psi,\n#                     distr = dmarg_c,\n#                     qparameters = list(c(lambda = lambda),\n#                                        c(lambda = lambda),\n#                                        c(lambda = lambda)))\n#   # Equivalent to\n#   X_norm <- rsmvnorm(R = n,\n#                      cor.matrix = Psi)\n#   X_pois_norta <- qpois(pnorm(X_norm), lambda = lambda) # !!!\n\n#   plot(density(X_qpois))\n#     lines(density(X_pois_norta), col = \"green\", lty = 2)\n\n# # Using Package SimCorMultRes ---------------------------------------------\n\n#   set.seed(123)\n#   sample_size <- 5000\n#   cluster_size <- 4\n#   beta_intercepts <- 0\n#   beta_coefficients <- 0.2  \n#   latent_correlation_matrix <- toeplitz(c(1, 0.9, 0.9, 0.9))\n#   x <- rep(rnorm(sample_size), each = cluster_size)\n#   simulated_binary_dataset <- rbin(clsize = cluster_size,\n#                                    intercepts = beta_intercepts, \n#                                    betas = beta_coefficients,\n#                                    xformula = ~x, \n#                                    cor.matrix = latent_correlation_matrix, \n#                                    link = \"probit\")\n#   simulated_binary_dataset$simdata\n#   cor(simulated_binary_dataset$Ysim)\n#   cor(simulated_binary_dataset$rlatent)\n  \n  \n#   library(gee)\n#   binary_gee_model <- gee(y ~ x, family = binomial(\"probit\"), id = id,\n#                           data = simulated_binary_dataset$simdata)\n#   summary(binary_gee_model)$coefficients\n\n# # Sample from the skewed normal dist by manual NORTA ----------------------\n# # (univariate)\n\n# # Packages\n# library(sn)\n# library(moments)\n\n# # Univariate case (Skewed normal)\n# n <- 1e5\n# mu <- 0\n# sd <- 1\n# skew <- .8 # target skewness\n\n# # Define parameters for the quantile functions of the skewd normal distribution\n# cp <- c(mean = mu, s.d. = sd, gamma1 = skew) # central parametrization\n# dp <- cp2dp(cp, family = \"SN\") # direct parametrization\n\n# # Obtain samples\n# set.seed(20211104)\n#   # NORTA\n#   x_norm <- rnorm(n, mu, sd) # step 1\n#   x_snorm <- qsn(pnorm(x_norm), dp = dp) # step 2\n\n#   # Azzalini method\n#   x_sn <- rsn(n, dp = dp)\n\n# # Skewness\n# skewness(x_sn)\n# skewness(x_snorm)\n\n# # Kurtosis\n# kurtosis(x_sn)\n# kurtosis(x_snorm)\n\n# # Densities\n# plot(density(x))  \n#   lines(density(x_snorm), col = \"blue\", lty = 2)\n\n# # Overcome skewed normal distribution limit of gamma < 1 ----------------------\n\n#   # The SKewed normal has the limit of gamma < 1\n\n#   # This works\n#   cp <- c(0, 1, .8)\n#   dp <- cp2dp(cp, family = \"SN\")\n#   x <- rsn(1e5, dp = dp)\n#   e1071::skewness(x)\n#   e1071::kurtosis(x)\n\n#   # But this does not\n#   cp <- c(0, 1, 2)\n#   dp <- cp2dp(cp, family = \"SN\")\n\n#   # So we move to the Skewed t distribution which allows changing the excess kurtosis\n#   cpST <- c(0, 1, 2, 10)\n#   dpST <- cp2dp(cpST, family = \"ST\")\n#   x <- rst(1e6, dp = dpST)\n#   plot(density(x))\n#   e1071::skewness(x)\n#   e1071::kurtosis(x)\n\n#   # Note a normal distribution with kurtosis\n#   cpST <- c(0, 1, 0, 0)\n#   dpST <- cp2dp(cpST, family = \"ST\")\n#   x <- rst(1e5, dp = dpST)\n#   e1071::skewness(x)\n#   e1071::kurtosis(x)\n\n#   z <- rnorm(1e5)\n#   e1071::skewness(z)\n#   e1071::kurtosis(z)\n\n#   plot(density(x))\n#   lines(density(rnorm(1e4)))\n\n#   # Push it even more\n#   cpST <- c(0, 1, 3, 40)\n#   dpST <- cp2dp(cpST, family = \"ST\")\n#   x <- rst(1e6, dp = dpST)\n#   plot(density(x))\n#   e1071::skewness(x)\n#   e1071::kurtosis(x)\n```\n:::\n\n\n# References",
    "supporting": [
      "norta_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}