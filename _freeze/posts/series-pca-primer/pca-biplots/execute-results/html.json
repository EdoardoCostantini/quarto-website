{
  "hash": "0a044015cdb9be411ac39cea1a31e443",
  "result": {
    "markdown": "---\ntitle: How to obtain PCA biplots\nauthor: Edoardo Costantini\ndate: '2022-12-08'\nslug: pca-biplots\ncategories: [\"PCA\", \"Interpretation\"]\nbibliography: ../../resources/bibshelf.bib\n---\n\n\n## Introduction\n\n**Principal Component Analysis** (PCA) is a technique that finds a low-dimensional representation of a large set of variables contained in an $n \\times p$ data matrix $\\mathbf{X}$ with minimal loss of information.\nIn terms of visualization techniques, PCA allows the representation of large datasets in a bi-dimensional plot.\nIn general, **biplots** give use a simultaneous representation of $n$ observations and $p$ variables on a single bi-dimensional plot.\nMore precisely, biplots represent the scatterplot of the observations on the first two principal components computed by PCA and the relative position of the $p$ variables in a two-dimensional space.\nFor an in-depth discussion, I recommend reading @jolliffe:2002 [p. 90].\n\n## Learn by coding\n\nLet us start by loading the `ggfortify` R package, which provides pleasant looking biplots.\nWe will work with the first four columns of the `iris` data, which report the length and width of petals and sepals in plants for the iris flowering plant.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prepare environment ----------------------------------------------------------\n\n# Load packages (install if you don't have it)\nlibrary(ggfortify) # for default biplots\n\n# Keep the numeric variables from the iris dataset.\nX <- iris[1:4]\n```\n:::\n\n\nWe then use the `prcomp` R function to compute the PCs of `X`. We specify the `prcomp` function to not scale and standardize the data because we rather have more control over how the standardization is performed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform PCA ------------------------------------------------------------------\n\n# Center and standardize the data\nX_sc <- scale(X)\n\n# Compute PCs\npca_res <- prcomp(X_sc, center = FALSE, scale. = FALSE)\n\n# Generate default biplot with ggfortify\nautoplot(pca_res,\n    data = X,\n    loadings.label = TRUE, \n    loadings.colour = \"blue\"\n)\n```\n\n::: {.cell-output-display}\n![](pca-biplots_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nand print the biplot obtained with the `ggfortify::autoplot()` function.\nWe specify which data should be plotted (`data = X`), and we require the loadings to be included in the plot as blue arrows (`loadings.colour = \"blue\"` and `loadings.label = TRUE`.)\n\nNow we replicate this plot by doing all the work ourselves. First, let's start by computing the PC scores ourselves by taking the singular value decomposition of X and computing the PC scores $T$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Getting to the biplots ------------------------------------------------------------------\n\n# SVD of X\nx_svd <- svd(X_sc)\n\n# Extract the parts of the SVD we need to compute the Principal Component scores\nU <- x_svd$u\nD <- diag(x_svd$d)\nV <- x_svd$v\n\n# Compute the PCs\nT <- U %*% D\n```\n:::\n\n\nWe can now make a scatter plot of the observations based on how they score on the first two PCs we computed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# > Simple scatter plot --------------------------------------------------------\nplot(\n    x = T[, 1], xlab = \"PC1\",\n    y = T[, 2], ylab = \"PC2\"\n)\n```\n\n::: {.cell-output-display}\n![](pca-biplots_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nThe next step is to overlay the arrows plotting the information regarding the loadings.\nWe want to plot a single arrow for each column of the original data, starting at the center of the plot ($PC1 = 0$, and $PC2 = 0$) and ending at the coordinates described by the first two columns of the component loadings matrix $V$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# > Adding loading arrows ------------------------------------------------------\n\n# Scatter plot\nplot(\n    x = T[, 1], xlab = \"PC1\",\n    y = T[, 2], ylab = \"PC2\"\n)\n\n# Add arrows from 0 to loading on the selected PCs (scaled up)\narrows(\n    x0 = rep(0, ncol(X)), x1 = V[, 1], \n    y0 = rep(0, ncol(X)), y1 = V[, 2]\n)\n```\n\n::: {.cell-output-display}\n![](pca-biplots_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\nWe can improve the visualization by adding a few teaks. Let's add a title, make the scatterplot symbols gray solid dots, scale up the arrow size, and add labels indicating which loading we are plotting with any given arrow.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# > Improving the visuals ------------------------------------------------------\n\n# Define a scaling factor for the arrows\nsf <- 2\n\n# Start over with the original scatterplot\nplot(\n    x = T[, 1], xlab = \"PC1\",\n    y = T[, 2], ylab = \"PC2\",\n    main = \"PCA biplot\", # plot title\n    col = \"gray\",\n    pch = 19 # solid circle\n)\n\n# Add arrows from 0 to loading on the selected PCs (scaled up)\narrows(\n    x0 = rep(0, ncol(X)), x1 = V[, 1] * sf, \n    y0 = rep(0, ncol(X)), y1 = V[, 2] * sf,\n    col = \"darkgray\"\n)\n\n# Add names of variables per arrow\ntext(x = V[, 1] * sf, y = V[, 2] * sf, labels = colnames(X))\n```\n\n::: {.cell-output-display}\n![](pca-biplots_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nThe scaling we performed is ad-hoc. We looked at the plot and decided to increase the size of the arrows by an arbitrary scaling factor. In the literature on biplots it is more common to scale both component scores and loadings by taking powers of the diagonal matrix $D$ and recomputing the coordinates[^1].\n\n[^1]: [https://blogs.sas.com/content/iml/2019/11/06/what-are-biplots.html](https://blogs.sas.com/content/iml/2019/11/06/what-are-biplots.html)\n\n## TL;DR, just give me the code!\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prepare environment ----------------------------------------------------------\n\n# Load packages (install if you don't have it)\nlibrary(ggfortify) # for default biplots\n\n# Keep the numeric variables from the iris dataset.\nX <- iris[1:4]\n\n\n# Perform PCA ------------------------------------------------------------------\n\n# Center and standardize the data\nX_sc <- scale(X)\n\n# Compute PCs\npca_res <- prcomp(X_sc, center = FALSE, scale. = FALSE)\n\n# Generate default biplot with ggfortify\nautoplot(pca_res,\n    data = X,\n    loadings.label = TRUE, \n    loadings.colour = \"blue\"\n)\n\n# Getting to the biplots ------------------------------------------------------------------\n\n# SVD of X\nx_svd <- svd(X_sc)\n\n# Extract the parts of the SVD we need to compute the Principal Component scores\nU <- x_svd$u\nD <- diag(x_svd$d)\nV <- x_svd$v\n\n# Compute the PCs\nT <- U %*% D\n\n# > Simple scatter plot --------------------------------------------------------\nplot(\n    x = T[, 1], xlab = \"PC1\",\n    y = T[, 2], ylab = \"PC2\"\n)\n\n# > Adding loading arrows ------------------------------------------------------\n\n# Scatter plot\nplot(\n    x = T[, 1], xlab = \"PC1\",\n    y = T[, 2], ylab = \"PC2\"\n)\n\n# Add arrows from 0 to loading on the selected PCs (scaled up)\narrows(\n    x0 = rep(0, ncol(X)), x1 = V[, 1], \n    y0 = rep(0, ncol(X)), y1 = V[, 2]\n)\n\n# > Improving the visuals ------------------------------------------------------\n\n# Define a scaling factor for the arrows\nsf <- 2\n\n# Start over with the original scatterplot\nplot(\n    x = T[, 1], xlab = \"PC1\",\n    y = T[, 2], ylab = \"PC2\",\n    main = \"PCA biplot\", # plot title\n    col = \"gray\",\n    pch = 19 # solid circle\n)\n\n# Add arrows from 0 to loading on the selected PCs (scaled up)\narrows(\n    x0 = rep(0, ncol(X)), x1 = V[, 1] * sf, \n    y0 = rep(0, ncol(X)), y1 = V[, 2] * sf,\n    col = \"darkgray\"\n)\n\n# Add names of variables per arrow\ntext(x = V[, 1] * sf, y = V[, 2] * sf, labels = colnames(X))\n```\n:::\n\n\n## References",
    "supporting": [
      "pca-biplots_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}