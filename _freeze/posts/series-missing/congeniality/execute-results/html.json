{
  "hash": "c90752343ce7a622b978e0fee9d01cd8",
  "result": {
    "markdown": "---\ndraft: true\ntitle: Conginiality\nauthor: Edoardo Costantini\ndate: '2022-03-14'\nslug: conginiality\ncategories: [\"Missing data\"]\nbibliography: ../../resources/bibshelf.bib\n---\n\n\n# Superefficiency\n\n::: {.cell}\n\n```{.r .cell-code}\n# Project:   blogdown\n# Objective: Study of superefficiency as presented by Rubin 1996 and Meng 1994\n# Author:    Edoardo Costantini\n# Created:   2022-04-14\n# Modified:  2022-04-14\n\nrm(list = ls())\n\n# Pacakges\nlibrary(splitstackshape)\n\n# Define population\nN <- 1e4\n\ndat <- data.frame(y = rnorm(N, mean = 0, sd = 1),\n                 x = c(rep(\"a\", N/2), rep(\"b\", N/2)))\n\ntable(dat$x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n   a    b \n5000 5000 \n```\n:::\n\n```{.r .cell-code}\n# Sample\nn <- 100 # sample stratum size\ndat_start <- stratified(indt = dat, group = \"x\", size = n)\nsmp_og <- smp <- as.data.frame(dat_start)\n\n# Missing values\nn0 <- .4 * n # number of missing cases in each group\n\nsmp[smp$x == \"a\", ][sample(1:n, n0), \"y\"] <- NA\nsmp[smp$x == \"b\", ][sample(1:n, n0), \"y\"] <- NA\n\n# Estimands\ny_bar_a <- mean(smp[smp$x == \"a\", \"y\"], na.rm = TRUE)\ny_bar_b <- mean(smp[smp$x == \"a\", \"y\"], na.rm = TRUE)\ny_bar <- (y_bar_a + y_bar_b)/2\nD_bar <- y_bar_a - y_bar_b\n\n# Multiply impute the data with the knowledge of groups having same distribution\n\nRi <- !is.na(smp$y)   # R = 1 observe, R = 0 missing\nm <- 50\ny_bar_obs <- mean(smp$y, na.rm = TRUE)\n\n# Obtain multiply imputed ys\n  y_imp <- lapply(1:m, function (i){\n    # Sample imputaions\n    y_imps <- rnorm(n    = sum(!Ri),\n                    mean = 0,\n                    sd   = 1)\n\n    # Create copy of original y with missing values\n    y_fill <- smp$y\n\n    # Fill in the imputation\n    y_fill[!Ri] <- y_imps\n\n    # Return the imputed variable\n    return(y_fill)\n  })\n\n# Perform a complete data procedure (Pcom) on every imputated dataset\n  Pcoms <- sapply(y_imp, function (j){\n    c(theta     = mean(j),        # mean of y in group x = 1\n      var_theta = length(j)^(-1)) # standard error of mean of y in group x = 1\n  } )\n\n# Pool the estimates to obtain Pm\n  theta_bar_m <- mean(Pcoms[1, ])\n  U_bar_m     <- mean(Pcoms[2, ])\n  Bm          <- 1/(m-1) * sum((Pcoms[1, ] - theta_bar_m)^2)\n  Tm          <- U_bar_m + (1+1/m) * Bm\n  Pm_unco     <- c(theta     = theta_bar_m,\n                   var_theta = Tm)\n\n# Estimates with comeplte data\n  Pog <- c(theta     = mean(smp_og$y),\n           var_theta = nrow(smp_og)^(-1))\n\ndata.frame(Pog = Pog,\n           Pm_unco = Pm_unco)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                Pog     Pm_unco\ntheta     0.0611427 0.063505262\nvar_theta 0.0050000 0.006130464\n```\n:::\n:::\n\n\n# Uncongeniality\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Project:   blogdown\n# Objective: Description of main uncongenial situations\n# Author:    Edoardo Costantini\n# Created:   2022-04-08\n# Modified:  2022-04-08\n\n# Set up environement ----------------------------------------------------------\n\nlibrary(mice)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'mice'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:stats':\n\n    filter\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    cbind, rbind\n```\n:::\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages\n───────────────────────────────────────\ntidyverse 1.3.2 ──\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ ggplot2 3.3.6      ✔ purrr   0.3.4 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.2      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks mice::filter(), stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n\n```{.r .cell-code}\n# Uncongenial form 1: imputation model is less complex than true model ---------\n\n# Meng 1994 --------------------------------------------------------------------\n\n# Data\nset.seed(20220408)\nn <- 1e4\nx <- sample(c(0, 1), size = n, replace = TRUE)\ny <- rnorm(n, sd = 1) + 5 * x\n\n# Variances in the groups are the same\ntapply(X = y, INDEX = x, FUN = var)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       0        1 \n1.001275 1.022433 \n```\n:::\n\n```{.r .cell-code}\n# Group means are different\ntapply(X = y, INDEX = x, FUN = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         0          1 \n0.01003174 4.98765295 \n```\n:::\n\n```{.r .cell-code}\n# Impose MAR missingnes on y\nampute_out <- ampute(cbind(y, x),\n                     patterns = c(0, 1),\n                     mech = \"MAR\")\ny_NAs <- ampute_out$amp[, \"y\"]\n\n# Imputer assumes more ---------------------------------------------------------\n\n# Analyst's parameter of interest estiamted on complete data\n\n  Pog <- c(theta     = mean(y[x == 1]),\n           var_theta = sum(x == 1)^(-1))\n\n# Define useful objects\n\n  Ri        <- !is.na(y_NAs)   # R = 1 observe, R = 0 missing\n  n_exc     <- sum(Ri)         # number of obserserved cases on y\n  y_bar_exc <- mean(y_NAs[Ri]) # mean of y using only observed cases\n\n  # Group objects\n  n_j0        <- sum(x == 0)              # sample size in x = 0\n  n_j0_exc    <- sum(x == 0 & Ri)         # observed y size in x = 0\n  n_j0_que    <- n_j0 - n_j0_exc          # missing y size in x = 0\n  ybar_j0_exc <- mean(y_NAs[x == 0 & Ri]) # mean observed in x = 0\n\n  n_j1        <- sum(x == 1)              # sample size in x = 1\n  n_j1_exc    <- sum(x == 1 & Ri)         # observed y size in x = 1\n  n_j1_que    <- n_j1 - n_j1_exc          # missing y size in x = 1\n  ybar_j1_exc <- mean(y_NAs[x == 1 & Ri]) # mean observed in x = 1\n\n# Incomplete data procedure (listwise deletion)\n\n  Pobs <- c(theta = ybar_j1_exc,\n            var_theta = n_j1_exc^(-1))\n\n# Complete data procedure through (uncongenial) imputation\n\n  # Define the number of imputations\n  m <- 10\n\n  # Obtain multiply imputed ys\n  y_imp <- lapply(1:m, function (i){\n    # Sample imputaions\n    y_imps <- rnorm(n    = sum(!Ri),\n                    mean = mean(y_NAs[Ri]),\n                    sd   = 1)\n\n    # Create copy of original y with missing values\n    y_fill <- y_NAs\n\n    # Fill in the imputation\n    y_fill[!Ri] <- y_imps\n\n    # Return the imputed variable\n    return(y_fill)\n  })\n\n  # Perform a complete data procedure (Pcom) on every imputated dataset\n  Pcoms <- sapply(y_imp, function (j){\n    c(theta     = mean(j[x == 1]),        # mean of y in group x = 1\n      var_theta = length(j[x == 1])^(-1)) # standard error of mean of y in group x = 1\n  } )\n\n  # Pool the estimates to obtain Pm\n  theta_bar_m <- mean(Pcoms[1, ])\n  U_bar_m     <- mean(Pcoms[2, ])\n  Bm          <- 1/(m-1) * sum((Pcoms[1, ] - theta_bar_m)^2)\n  Tm          <- U_bar_m + (1+1/m) * Bm\n  Pm_unco     <- c(theta     = theta_bar_m,\n                   var_theta = Tm)\n\n# Compare results\n\n  round(cbind(Pog, Pobs, Pm_unco), 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              Pog    Pobs Pm_unco\ntheta     4.98765 4.96258 2.32302\nvar_theta 0.00020 0.00075 0.00031\n```\n:::\n\n```{.r .cell-code}\n  # Super-efficiency\n  # set.seed(20220408)\n  # y <- rnorm(n, sd = 1) + 0 * x # group means are the same!\n  # imputer knows!\n  # analyst doesn't\n\n# Imputer assumes less ---------------------------------------------------------\n\n# Analyst's parameter of interest estiamted on complete data\n\n  Pog <- c(theta     = mean(y),\n           var_theta = n^(-1))\n\n# > a) MCAR Data - Missing data is missing at completely at random -------------\n\n# Impose missing values\n\n  set.seed(20220411)\n  ym <- ampute(cbind(y, x),\n               patterns = c(0, 1),\n               mech = \"MCAR\")$amp[, \"y\"]\n\n# Compute all of the objects of interest\n\n  Ri        <- !is.na(ym)   # R = 1 observe, R = 0 missing\n  n_exc     <- sum(Ri)      # number of obserserved cases on y\n  y_bar_exc <- mean(ym[Ri]) # mean of y using only observed cases\n\n  n_j0        <- sum(x == 0)              # sample size in x = 0\n  n_j0_exc    <- sum(x == 0 & Ri)         # observed y size in x = 0\n  n_j0_que    <- n_j0 - n_j0_exc          # missing y size in x = 0\n  ybar_j0_exc <- mean(ym[x == 0 & Ri]) # mean observed in x = 0\n\n  n_j1        <- sum(x == 1)              # sample size in x = 1\n  n_j1_exc    <- sum(x == 1 & Ri)         # observed y size in x = 1\n  n_j1_que    <- n_j1 - n_j1_exc          # missing y size in x = 1\n  ybar_j1_exc <- mean(ym[x == 1 & Ri]) # mean observed in x = 1\n\n# Incomplete data procedure\n\n  # Incomplete data procedure 1: unkown x\n  Pobs_1 <- c(Qh = y_bar_exc,\n              U  = n_exc^(-1))\n\n    # the computation of the mean is equivalent to computing\n    (n_j1_exc / n_exc * ybar_j1_exc + n_j0_exc / n_exc * ybar_j0_exc) - Pobs_1[\"Qh\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nQh \n 0 \n```\n:::\n\n```{.r .cell-code}\n  # Incomplete data procedure 2: known x\n  Pobs_2 <- c(Qh = n_j1 / n * ybar_j1_exc + n_j0 / n * ybar_j0_exc,\n              U  = n^(-1))\n\n# Complete data procedure with imputations under more general model\n\n  # Impute values\n  y_imp <- lapply(1:m, function (i){\n\n    # For x = 1\n    theta1 <- rnorm(1, ybar_j1_exc, n_j1_exc^(-1))\n    y_imps_j1 <- rnorm(sum(!Ri & x == 1), mean = theta1, sd = 1)\n\n    # For x = 0\n    theta0 <- rnorm(1, ybar_j0_exc, n_j0_exc^(-1))\n    y_imps_j0 <- rnorm(sum(!Ri & x == 0), mean = theta0, sd = 1)\n\n    # Fill missing vlaues\n    y_fill <- ym\n    y_fill[x == 0 & !Ri] <- y_imps_j0\n    y_fill[x == 1 & !Ri] <- y_imps_j1\n\n    # Returns\n    return(y_fill)\n  })\n\n  # Perform a complete data procedure (Pcom) on every imputated dataset\n  Pcoms <- sapply(y_imp, function (j){\n    c(Qh = mean(j),        # mean of y in the population\n      U  = length(j)^(-1)) # standard error of population mean of y\n  } )\n\n  # Pool the estimates to obtain Pm\n  theta_bar_m <- mean(Pcoms[1, ])\n  U_bar_m <- mean(Pcoms[2, ])\n  Bm <- 1/(m-1) * sum((Pcoms[1, ] - theta_bar_m)^2)\n  Tm <- U_bar_m + (1+1/m) * Bm\n  Pm_cong <- c(Qh = theta_bar_m,\n               U = Tm)\n\n# Compare results\n\n  MCAR_results <- round(cbind(Pog, Pobs_1, Pobs_2, Pm_cong), 5)\n\n# > b) MAR Data - Missing values are missing at random (depend on X) -----------\n\n# Impose missing values\n\n  set.seed(20220411)\n  ym <- ampute(cbind(y, x),\n               patterns = c(0, 1),\n               mech = \"MAR\")$amp[, \"y\"] # MAR instead of MCAR\n\n# Compute all of the objects of interest\n\n  Ri        <- !is.na(ym)   # R = 1 observe, R = 0 missing\n  n_exc     <- sum(Ri)      # number of obserserved cases on y\n  y_bar_exc <- mean(ym[Ri]) # mean of y using only observed cases\n\n  n_j0        <- sum(x == 0)              # sample size in x = 0\n  n_j0_exc    <- sum(x == 0 & Ri)         # observed y size in x = 0\n  n_j0_que    <- n_j0 - n_j0_exc          # missing y size in x = 0\n  ybar_j0_exc <- mean(ym[x == 0 & Ri]) # mean observed in x = 0\n\n  n_j1        <- sum(x == 1)              # sample size in x = 1\n  n_j1_exc    <- sum(x == 1 & Ri)         # observed y size in x = 1\n  n_j1_que    <- n_j1 - n_j1_exc          # missing y size in x = 1\n  ybar_j1_exc <- mean(ym[x == 1 & Ri]) # mean observed in x = 1\n\n# Incomplete data procedure\n\n  # Incomplete data procedure 1: unkown x\n  Pobs_1 <- c(Qh = y_bar_exc,\n              U  = n_exc^(-1))\n\n    # the computation of the mean is equivalent to computing\n    (n_j1_exc / n_exc * ybar_j1_exc + n_j0_exc / n_exc * ybar_j0_exc) - Pobs_1[\"Qh\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Qh \n2.220446e-16 \n```\n:::\n\n```{.r .cell-code}\n  # Incomplete data procedure 2: known x\n  Pobs_2 <- c(Qh = n_j1 / n * ybar_j1_exc + n_j0 / n * ybar_j0_exc,\n              U  = n^(-1))\n\n# Complete data procedure with imputations under more general model\n\n  # Impute values\n  y_imp <- lapply(1:m, function (i){\n\n    # For x = 1\n    theta1 <- rnorm(1, ybar_j1_exc, n_j1_exc^(-1))\n    y_imps_j1 <- rnorm(sum(!Ri & x == 1), mean = theta1, sd = 1)\n\n    # For x = 0\n    theta0 <- rnorm(1, ybar_j0_exc, n_j0_exc^(-1))\n    y_imps_j0 <- rnorm(sum(!Ri & x == 0), mean = theta0, sd = 1)\n\n    # Fill missing vlaues\n    y_fill <- ym\n    y_fill[x == 0 & !Ri] <- y_imps_j0\n    y_fill[x == 1 & !Ri] <- y_imps_j1\n\n    # Returns\n    return(y_fill)\n  })\n\n  # Perform a complete data procedure (Pcom) on every imputated dataset\n  Pcoms <- sapply(y_imp, function (j){\n    c(Qh = mean(j),        # mean of y in the population\n      U  = length(j)^(-1)) # standard error of population mean of y\n  } )\n\n  # Pool the estimates to obtain Pm\n  theta_bar_m <- mean(Pcoms[1, ])\n  U_bar_m <- mean(Pcoms[2, ])\n  Bm <- 1/(m-1) * sum((Pcoms[1, ] - theta_bar_m)^2)\n  Tm <- U_bar_m + (1+1/m) * Bm\n  Pm_cong <- c(Qh = theta_bar_m,\n               U = Tm)\n\n# Compare results\n\n  MAR_results <- round(cbind(Pog, Pobs_1, Pobs_2, Pm_cong), 5)\n\n# > When is what statistically valid? ------------------------------------------\nMCAR_results\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              Pog  Pobs_1 Pobs_2 Pm_cong\ntheta     2.45454 2.47336 2.4527 2.44956\nvar_theta 0.00010 0.00020 0.0001 0.00013\n```\n:::\n\n```{.r .cell-code}\nMAR_results\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              Pog  Pobs_1  Pobs_2 Pm_cong\ntheta     2.45454 1.30477 2.46956 2.46659\nvar_theta 0.00010 0.00020 0.00010 0.00014\n```\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}